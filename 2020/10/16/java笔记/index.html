<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">






  <meta name="keywords" content="java," />










<meta name="description" content="Java小学期笔记Java vs C++1, 数据类型​    *基本数据类型：byte(8bits)   short(16bits)   int(43bits)   long(64bits)   float(32bits)   double(64bits)  char(16bits)   boolean ​    char string 用unicode编码格式(双字节编码) -可表示字母 汉字">
<meta property="og:type" content="article">
<meta property="og:title" content="java笔记">
<meta property="og:url" content="https://chocofairy.github.io/2020/10/16/java%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="巧克力梦工厂">
<meta property="og:description" content="Java小学期笔记Java vs C++1, 数据类型​    *基本数据类型：byte(8bits)   short(16bits)   int(43bits)   long(64bits)   float(32bits)   double(64bits)  char(16bits)   boolean ​    char string 用unicode编码格式(双字节编码) -可表示字母 汉字">
<meta property="og:locale">
<meta property="og:image" content="https://chocofairy.github.io/images/1568274579253.png">
<meta property="og:image" content="https://chocofairy.github.io/images/1577624122812.png">
<meta property="og:image" content="https://chocofairy.github.io/images/1569217469521.png">
<meta property="og:image" content="https://chocofairy.github.io/images/1570858700925.png">
<meta property="og:image" content="https://chocofairy.github.io/images/1577616911675.png">
<meta property="article:published_time" content="2020-10-16T13:02:59.000Z">
<meta property="article:modified_time" content="2021-03-21T08:58:33.544Z">
<meta property="article:author" content="wlz">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chocofairy.github.io/images/1568274579253.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":20,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ChocoFairy.github.io/2020/10/16/java笔记/"/>





  <title>java笔记 | 巧克力梦工厂</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">巧克力梦工厂</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小仙女的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ChocoFairy.github.io/2020/10/16/java%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="巧克力梦工厂">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-16T21:02:59+08:00">
                2020-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/start-program/" itemprop="url" rel="index">
                    <span itemprop="name">start_program</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.5k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java小学期笔记"><a href="#Java小学期笔记" class="headerlink" title="Java小学期笔记"></a>Java小学期笔记</h1><h2 id="Java-vs-C"><a href="#Java-vs-C" class="headerlink" title="Java vs C++"></a>Java vs C++</h2><h5 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1, 数据类型"></a>1, 数据类型</h5><p>​    *基本数据类型：byte(8bits)   short(16bits)   int(43bits)   long(64bits)   float(32bits)   double(64bits)  char(16bits)   boolean</p>
<p>​    char string 用unicode编码格式(双字节编码) -可表示字母 汉字 日文等  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;\u0065&#x27;</span>;</span><br><span class="line"><span class="comment">// 禁止 大数据类型给小数据类型赋值-syntax error</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">3.14F</span>;   <span class="comment">// (数值类型默认double)</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">011</span>;    <span class="comment">// 八进制</span></span><br></pre></td></tr></table></figure>

<p>​    *引用数据类型： Object （every thing is Object ）</p>
<h5 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2, 参数传递"></a>2, 参数传递</h5><p>​    只有传值一种方式 </p>
<h5 id="3-对象存储与访问"><a href="#3-对象存储与访问" class="headerlink" title="3, 对象存储与访问"></a>3, 对象存储与访问</h5><p>​    除非用new创建对象，否则，实际上并未获得任何对象</p>
<p>​    对象全部存储在堆中，栈中没有对象，  访问对象的唯一方法是 ‘引用’（引用的大小：8byte）</p>
<h5 id="4-对象回收"><a href="#4-对象回收" class="headerlink" title="4, 对象回收"></a>4, 对象回收</h5><p>​    没有引用的对象 是垃圾对象，JVM的垃圾回收机制将自动回收，但不知道何时进行。（System.gc()仅是发一个回收请求，并不立刻进行）</p>
<span id="more"></span>

<h2 id="Java中的运算"><a href="#Java中的运算" class="headerlink" title="Java中的运算"></a>Java中的运算</h2><h5 id="1-算术运算"><a href="#1-算术运算" class="headerlink" title="1,  算术运算"></a>1,  算术运算</h5><p>+；  -； *； /； %； ++； –；&gt;&gt; (右移，保证符号位不变);  <strong>&gt;&gt;&gt;</strong> (无符号右移，最高位只补零。注意：负数移位会变成正数);  &amp; (与);  | (或)；^ (异或); ~ (按位取反);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">i = i &gt;&gt; <span class="number">99</span>;</span><br><span class="line"><span class="comment">// -1的补码是全1，右移保证符号，故i移位后仍为-1</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">17</span>;</span><br><span class="line">j = j &lt;&lt; <span class="number">33</span>;    <span class="comment">// int只占32位，编译器会自动给33取32的模，于是等价于 j&lt;&lt;1</span></span><br><span class="line"><span class="comment">/*若是byte,short,char类型（是int型兼容的）进行算术运算，会自动进行类型提升，至int*/</span></span><br><span class="line"><span class="comment">// 故 byte，short，char的移位运算，移的位数仍然模32，而不是8，16</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">5</span>;</span><br><span class="line">s = (<span class="keyword">short</span>) (s + (<span class="keyword">byte</span>)<span class="number">9f</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;    <span class="comment">// 输出-24  （截断后最高为为1，则为负数）</span></span><br><span class="line"><span class="comment">//两个byte相与，类型为int，还需转换类型</span></span><br></pre></td></tr></table></figure>

<p>特别地，对于 = (赋值运算)，基本类型的赋值运算就是普通的内容复制；而对象的赋值实际上是将“引用”从一个地方复制到另一个地方，操纵的是“引用”</p>
<h5 id="2-关系运算"><a href="#2-关系运算" class="headerlink" title="2,  关系运算"></a>2,  关系运算</h5><p>&lt;;  &gt;;  &lt;=;  &gt;=;  ==;  !=;  instanceof; </p>
<p>instanceof用来在运行时指出对象是否是特定类(自己定义的)的一个实例。通过返回一个布尔值来指出，这个对象是否是这个<em>特定类或者是它的子类</em>的一个实例。（任何 对象 instanceof Object 结果为true，除了null）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unit u = <span class="keyword">new</span> Unit();</span><br><span class="line"><span class="keyword">if</span>(u <span class="keyword">instanceof</span> Object) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;True&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 True</span></span><br></pre></td></tr></table></figure>

<h5 id="3-逻辑运算"><a href="#3-逻辑运算" class="headerlink" title="3,  逻辑运算"></a>3,  逻辑运算</h5><p>&amp;&amp;（逻辑与）;  ||（短路）;  &amp; (与);  | (或)；^ (异或);</p>
<p>(思考：位与运算&amp;和逻辑与&amp;&amp;的区别， 位或运算|和短路运算||的区别)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">false</span> &amp; i++ &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">false</span> &amp;&amp; i++ &gt; <span class="number">10</span></span><br><span class="line"><span class="comment">//两者的区别是 最终的i值不同</span></span><br><span class="line"><span class="comment">//常见的安全代码-利用||处理空指针异常</span></span><br><span class="line">String username;</span><br><span class="line"><span class="keyword">if</span>(username == <span class="keyword">null</span> || username.length()==<span class="number">0</span>)&#123;<span class="comment">//发出警告&#125;</span></span><br></pre></td></tr></table></figure>

<p>*桶排序   进制问题</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。</p>
<p>具体体现是：</p>
<ul>
<li>不用创建类就可以直接通过”类名. “来访问</li>
<li>static的域是共享的，而与包含它的对象的实例个数无关（static字段对每个类来说只有一份存储空间，而非static字段则是对每个对象有一个存储空间）</li>
<li>static方法不能直接调用其他非static的域或方法</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>用于进行类的组织，处理命名冲突。<strong>包的命名须全小写（规范</strong>），不能以系统包名开头。</p>
<p>如果有包名，那么javac编译必须要加 -d 表示建立 package a.b; 中的 a.b 对应的文件夹 a\b<br>. (点) 表示 在当前路径下</p>
<p>java命令中给出 -classpath 选项，将在指定目录下去找class文件运行</p>
<p>jar 命令用于归档打包</p>
<p>*mainfest文件， 清单</p>
<h2 id="继承，多态，接口"><a href="#继承，多态，接口" class="headerlink" title="继承，多态，接口"></a>继承，多态，接口</h2><p>java中的继承是单一继承，若不显示指示则继承于Object</p>
<p>super 特指继承下来的父类（可多级），super() 仅能用于子类构造函数中，而super. 方法可以在子类其他函数中使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	A() &#123; <span class="keyword">this</span>.init(); &#125;    <span class="comment">// 2，此时调用的不是A的init()函数，而是B重写的init()</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">	    System.out.println(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">		j = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line">   B(<span class="keyword">int</span> j) &#123; <span class="keyword">this</span>.j = j; &#125;   <span class="comment">// 1，子类构造函数在基类构造之后，其实j赋值之前 默认有super()</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;     <span class="comment">// 3，此时调用该函数时，j并没有被赋值，默认初值为0</span></span><br><span class="line">	   System.out.println(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">	   System.out.println(j);</span><br><span class="line">	   j = <span class="number">4</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">new</span> B(<span class="number">5</span>).j);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终的输出是 p 0 5</span></span><br></pre></td></tr></table></figure>

<p>多态分为静态多态和动态多态。静态多态也叫重载，即同名函数，参数不同；Override 重写，在继承过程中，子类重写覆盖父类中的函数。   加final 或static 明确地在编译的时候确定，该函数在继承过程中将不进行重写，可提升性能。</p>
<p>函数覆盖的三个原则：</p>
<p>​    覆盖函数的访问权限不能比被覆盖的函数低</p>
<p>​    覆盖函数抛出的检查异常不能更多（不能抛出未声明的检查异常，运行异常如NullPointerException可以）</p>
<p>​    static，final函数不能被覆盖</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>java.util包下</p>
<p>集合最先只是定义了接口，Collections是大多数集合的公共基类</p>
<ul>
<li>List：*回去看文档    *Object 的hasCode</li>
<li>Set：</li>
<li>Map：</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>*为了保证灵活性和可扩展性，尽量少用常量（如文件名，且不用绝对路径）。</p>
<p>File f = new File(“a.dat”);   并不是创建了一个文件，而是在内存中创建了一个File对象</p>
<p>RandomAccessFile可进行读写，seek</p>
<p>流对象： 输入输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 流连接</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]);</span><br><span class="line">BufferInputStream bis = <span class="keyword">new</span> BufferInputStream(fis);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(bis);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = dis.readDouble();</span><br></pre></td></tr></table></figure>

<p>windows 是小端，而mac 大端（不同操作系统，大小端可能也不同）</p>
<p>*ObjectInputStream</p>
<p>java.io.Serializable 序列化接口，没有抽象方法（即标签接口），只是声明一下该对象是可序列化的，jvm可以在流中输出该对象</p>
<p>对象的.clone()是浅复制，若要自己实现深复制则可以利用文件（ObjectOutputStream）的序列化和反序列化来实现</p>
<p>文本文件 .dat   .txt   .docx   .pdf 等。 汉字编码2字节， 编码格式GB2312—GBK—GB18030</p>
<p>Unicode字符编码，2字节，java是统一编码Unicode;    utf-8 是可变长编码  基本的Unicode占1字节，中文3字节</p>
<p>FileReader fr = new FileReader(“a.txt”);   这个类使用的编码是与平台有关的（平台默认的编码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常的方法</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputSreamReader(fis));</span><br></pre></td></tr></table></figure>

<p>write时, \r\n是是平台有关的，可以使用PrintWriter的println函数跨平台地去处理换行</p>
<p>Properties 实现配置文件的读写</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Exception, Error 继承于Throwable, Error是致命的错误，机器直接停止运行/宕机，不说去处理它而出现异常，需要去处理。</p>
<p>对RuntimeException 编译器不做任何语法检查：</p>
<ul>
<li>NullPointerException（空指针异常）</li>
<li>ArithmeticException（算术异常）</li>
<li>ClassCastException（类转型异常）</li>
<li>IndexOutOfBoundsException（下标越界异常）</li>
<li>…</li>
</ul>
<p>而对CheckException 编译器会做语法检查。</p>
<ul>
<li>FileNotFoundException</li>
<li>IOException</li>
<li>SQLException</li>
<li>…</li>
</ul>
<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p>必要的时候，经常进行一下Thread.sleep(), 睡眠时间可能会长于规定的时间，因为sleep()后线程重新向处理器请求调度</p>
<p>创建线程的两种方法：</p>
<ol>
<li>实现Runnable接口传入Thread构造函数</li>
<li>继承Thread类实现run()方法</li>
</ol>
<p>多线程的同步：synchronized   每一个对象都有一个对象锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Objecct lock1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">synchronized</span>（Obejct o）&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait() 封装在Obejct中，调用该函数的对象必须持有该对象的对象锁</p>
<p>notify() 与 notifyAll() : 唤醒当前对象锁处于wait()状态的线程    * 进入wait()的条件(阻塞条件)应该用while</p>
<p>notifyAll() 唤醒所有处于阻塞状态的线程，但进入阻塞是用的while，可以带来更好的安全性</p>
<p>*对象池    Object 的wait() , notify() , notifyAll()</p>
<p>ThreadLocal类，内部用Map来存储不同的线程变量，key: 线程  value: 变量。 可以用来隐含地参数传递。</p>
<p>+</p>
<p>组合与聚合：与主体生命周期一致的称为组合，组合是更强烈的聚合</p>
<p>*派生属性占用内存，而且致命的是派生属性的同步问题！！</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>Socket  以流的方式进行数据传输    （json数据格式）</p>
<p>服务器端，ServerSocket 指定监听的端口，  .accept() 接收客户端请求，实施监听进行阻塞</p>
<p>（可先发一个整数，在服务器端进行功能选择） 传送文件之前， 先把文件名， 文件长度发给对方</p>
<p>readFully() 缓冲区数据有多长就读多少</p>
<p>&amp;小技巧：“upload”.equals(command)   有效防止了空指针异常</p>
<p>*工厂模式</p>
<p>服务器支持多并发：while 中不停地接收请求创建Socket， 创建的每一个Socket给一个线程（提前创建线程池）去处理。线程由线程池中取出，提高效率。     线程中run() 第一条应该是wait() ,    收到请求后处理相应的逻辑</p>
<p>HashMap 是线程不安全的， HashTable 是线程安全的。  可用下面方法将集合转换成线程安全的</p>
<p>Map map =  Collections.synchronizedMap(map); </p>
<p>TreeSet, TreeMap 中若有自定义的对象，则对象要实现Comparable接口，以进行比较</p>
<h2 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h2><p>event (接口),  event source (事件源)   </p>
<p>ActionEvent,  MouseEvent,  KeyEvent,   FocusEvent</p>
<p>event都有一个函数getSource()方法</p>
<p>*java 命令行参数  -D可以设置系统属性  ，如用FileReader来读文件是与平台有关的，若想在日文系统中读中文文本，则可以 java -Dfile.encoding=gbk 类 来运行 </p>
<p>*装饰者模式</p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>常用的注解：@Override    @Deprecated      @SuppressWarnings  （用于压制程序中的警告，有{“unchecked”, “Deprecated”}等）</p>
<p>使用@interface Annotation{  } </p>
<p>一个@Annotation注解，一个注解是一个类</p>
<p>动态地根据类名创建实例：（类名）Beans.instantiate(ClassLoad cl, String className)</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwenbo0920/article/details/7290586">https://blog.csdn.net/liuwenbo0920/article/details/7290586</a></p>
<p>import static 类  ：表示导入该类所有的静态方法(原来Math.abs()，现在只用abs() ) </p>
<p>*java.lang.reflect</p>
<p>*TLV (TAG-LENGTH-VALUE)  变长数据传输的一种报文格式</p>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>创建完Connection之后，java会自动进行事务提交(con.commit())，若要自己提交事务则要在此处设置 con.setAutoCommit(false);</p>
<p>分布式事务（例子：跨行取钱），使用2PC来支持分布式事务</p>
<p>o/r mapping  对象关系 映射</p>
<p>*软件设计的一些原则： 开闭原则，依赖倒置原则，里氏替换原则，接口隔离原则</p>
<h1 id="J2EE笔记"><a href="#J2EE笔记" class="headerlink" title="J2EE笔记"></a>J2EE笔记</h1><p>tel: 18640857288    qq: 1458233700  email: <a href="mailto:&#x6a;&#103;&#x68;&#x40;&#x64;&#x6c;&#117;&#x74;&#x2e;&#101;&#x64;&#117;&#x2e;&#99;&#x6e;">&#x6a;&#103;&#x68;&#x40;&#x64;&#x6c;&#117;&#x74;&#x2e;&#101;&#x64;&#117;&#x2e;&#99;&#x6e;</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>j2ee是java se 的扩展，包名均以javax开头。java SE（桌面应用）, java EE（企业应用）, java ME （嵌入式应用）</p>
<p>javaEE平台很多都是接口，是一个抽象的平台称为“定义平台”。</p>
<p><strong>基于组件的开发</strong>，组件（如servlet）在容器中被调用。应用服务器软件：开源免费:  Apache-tomcat,  收费：IBM-WebSphere Application Server （WAS ）； Bea WebLogic </p>
<p>没有main函数，需要将项目部署(deploy)到Web服务器。打包成.war文件。</p>
<p><em>URL的格式（三个部分）：*<em>协议+主机(IP+端口)+文件路径</em></em> (例如： <a target="_blank" rel="noopener" href="https://127.0.0.1:8080/SearchPage/index.html?username=zzmine&amp;password=123456)%E3%80%82">https://127.0.0.1:8080/SearchPage/index.html?username=zzmine&amp;password=123456)。</a> url地址中？后面的内容叫作 查询字符串(Query String)</p>
<p>request和response的组成：headers和content，用两次回车换行分隔(\r\n)</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>[interface]   用于处理请求和发送响应，实现动态页面。</p>
<p>组件不能自己写构造函数，应用服务器会使用默认构造函数！！若要构造，应该<strong>重写</strong>其init(ServletConfig config)函数。HttpServlet已经实现了init()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种init方法</span></span><br><span class="line"><span class="comment">//1,带参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.init(config);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2,不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Servlet的service()方法，参数，返回类型以及抛出什么异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">    HttpServletRequest req = (HttpServletRequest)request;</span><br><span class="line">    HttpServletResponse res = (HttpServletResponse)response;</span><br><span class="line">	<span class="comment">// HttpServletReuqest的getMethod方法可以获得用户请求的方式(GET,POST等)</span></span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">    PrintWriter out = res.getWriter();</span><br><span class="line">    out.print(<span class="string">&quot;&lt;p&gt;Hello World&lt;/p&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 不建议写流的关闭，还有其他程序需要输出</span></span><br><span class="line">    <span class="comment">// 输出形式为jpeg图片</span></span><br><span class="line">    res.setContentType(<span class="string">&quot;image/jpeg;charset=utf-8&quot;</span>);</span><br><span class="line">    OutputStream out = res.getOutputStream();</span><br><span class="line">    out.write(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Servlet的生命周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)web容器加载Servlet,生命周期开始。（仅调用一次）说明Servlet是单实例的</span><br><span class="line">(2)调用servlet的init()方法，servlet初始化。（仅调用一次）</span><br><span class="line">(3)调用service()方式，处理请求（被多次调用）</span><br><span class="line">(4)结束服务，web容器调用servlet的destory()方法（仅调用一次）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>部署(deploy)的方法:</p>
<p>1, 将web应用(HelloServlet)直接复制在Tomcat的WebApps文件夹下, 则用户访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/HelloServlet/abc/h.html">http://localhost:8080/HelloServlet/abc/h.html</a> </p>
<p>2, 在Tomcat配置中的server.xml下部署：在Host元素下建子标签<content path="/abc" docBase="..."> 。path是url，docBase是文件的物理地址。则用户访问路径: <a target="_blank" rel="noopener" href="http://localhost:8080/abc/abc/h.html">http://localhost:8080/abc/abc/h.html</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.a.HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--备注:同一个Servlet可以被映射到多个URL上，配置多个servlet-mapping--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	url-pattern可以使用通配符，但既有斜杠又有扩展名是不合法的，如/*.html</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>*javax.websocket包下，Endpoint, Encoder, Decoder。双向发送数据，而Servlet是请求应答式单向的服务。</p>
<p><strong>ServletConfig, ServletContext</strong></p>
<p>ServletConfig有两个重要的方法：</p>
<ul>
<li>getInitParameter(String name) -获得初始化参数name的值，若没有对应于name的参数，那么返回null</li>
<li>getServletContext() -获得代表应用全局的ServletContext类</li>
</ul>
<p>ServletContext中有一系列add，set，get方法，用于Servlet与container的交流，<strong>可以当成一个web应用中所有构件的共享资源</strong></p>
<p>该对象代表当前的web应用，可以从中获取到该web应用的各种信息<br>① 配置，获取 web应用的初始化参数<br>该初始化参数可以被所有Servlet获取，而Servlet的初始化参数只供那个Servlet获取<br>在&lt; web-app&gt; 中配置 &lt; context-param&gt;<br>servletContext.getInitParameter()</p>
<p>② 获取当前web应用某个文件<strong>在服务器上</strong>的绝对路径，而不是部署前的路径：<br>getRealPath(String path)</p>
<p>③ 获取当前web应用的名称：<br>getContextPath()   若web应用直接放在root目录下，则request.getContextPath()返回为空串。</p>
<p>④ 获取当前web应用的某一个文件对应的输入流<br>getResourceAsStream(String path) path的 / 是相对于当前web应用的根目录</p>
<p>⑤ 跟attribute相关的几个方法</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangqing84411433/article/details/71131608">https://blog.csdn.net/wangqing84411433/article/details/71131608</a><br>1、在web.xml配置文件中，对个servlet的配置里，有一项&lt; load-on-startup&gt; &lt; /load-on-startup&gt;，它的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。</p>
<p>servlet_2虽然配置在servlet_1后面，但是它的load-on-startup为0，启动的优先级高于servlet_1，所以servlet_2先启动。</p>
<p>2、获取ServletContext的两种方式，直接获取 this.getServletContext()和间接获取config.getServletContext，得到的对象都是同一个。同时在servlet1和servlet2中取得的ServletContext对象都是同一个对象，<strong>说明整个web应用都只有一个唯一的ServletContext实例</strong>；</p>
<p>3、servlet1与servlet2的serveletConfig对象是不一样的，说明ServletConfig对象的作用范围仅在servlet中。</p>
<p>**HttpServlet **[abstract class]: 不去重写service()方法，而是去override doGet(), doPost()之类的方法。在多线程中注意并发资源的保护</p>
<p>在doGet()方法中注意处理content type以及encoding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ServletRequest</strong> [interface]:  </p>
<p><strong>HttpServletRequest</strong> [interface]: 继承ServletRequest，为Http servlet提供请求信息。</p>
<p>该对象提供的数据包括，参数名称和值，属性以及输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>&#123; &#125;   <span class="comment">// 从request域中取出对应name的数据</span></span><br><span class="line"><span class="function">String <span class="title">getParameter</span><span class="params">(String name)</span></span>&#123; &#125;   <span class="comment">// 从url中获取对应name的查询字符串的值，如果name参数不存在则返回null</span></span><br><span class="line">String[] getParameterValues(String name)&#123;&#125;  <span class="comment">// 对应name的多个值</span></span><br><span class="line"><span class="function">String <span class="title">getMethod</span><span class="params">()</span></span>&#123;&#125;                  <span class="comment">// 获得请求方式</span></span><br><span class="line"><span class="function">HttpSession <span class="title">getSession</span><span class="params">()</span></span>&#123;&#125;			 <span class="comment">// 返回Session</span></span><br><span class="line"><span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">// ServletRequest中的方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ServletResponse</strong> [interface]: </p>
<p><strong>HttpServletResponse</strong> [interface]: 继承ServletResponse，在发送响应式提供特定于http的功能。</p>
<p>用于向客户端返回数据。若要返回字符数据，可以通过getWriter()方法返回的PrintWriter对象来操作，它的write()方法不会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String charset)</span></span>&#123;&#125;    <span class="comment">// 设置response的字符编码，如utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String type)</span></span>&#123; &#125;    <span class="comment">// 设置response的内容格式，给定的内容可以包含字符编码规范。例如 “text/html;charset=utf-8”   如果在调用getWriter之前调用此方法，则仅从给定的内容类型设置响应的字符编码</span></span><br><span class="line"><span class="comment">// 注意： This method has no effect if called after the response has been committed. It does not set the response&#x27;s character encoding if it is called after getWriter has been called or after the response has been committed.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>HttpSession Api</p>
<p>可以设置session的生存/超时时间，但注意单位。tiemout通常单位是分钟。</p>
<p>session在内存中如何被创建？</p>
<p><img src="/images/1568274579253.png"></p>
<p>*memcached分布式缓存</p>
<p>HttpSession底层实现的三种方法（<a target="_blank" rel="noopener" href="https://blog.csdn.net/qfs_v/article/details/2652119%EF%BC%89%EF%BC%9A">https://blog.csdn.net/qfs_v/article/details/2652119）：</a></p>
<ol>
<li>*cookie技术</li>
<li>URL重写(rewrite) (浏览器不支持cookie时，可以用URL重写来代替)</li>
<li>隐藏表单域 （form表单有一个隐藏的input）</li>
</ol>
<p><strong>Annotation</strong>: 参考<a target="_blank" rel="noopener" href="https://j2eereference.com/webservlet-annotations/">https://j2eereference.com/webservlet-annotations/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.*;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@WebServlet(value=&quot;/hello&quot;,</span></span><br><span class="line"><span class="meta">initParams = &#123;</span></span><br><span class="line"><span class="meta">   @WebInitParam(name=&quot;param1&quot;, value=&quot;Hello &quot;),</span></span><br><span class="line"><span class="meta">   @WebInitParam(name=&quot;param2&quot;, value=&quot; World!&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, ServletException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		PrintWriter out = res.getWriter();</span><br><span class="line">		out.println(getInitParameter(<span class="string">&quot;param1&quot;</span>));</span><br><span class="line">		out.println(getInitParameter(<span class="string">&quot;param2&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="RequestDispatcher"></a>RequestDispatcher</h2><p>用于请求转发，页面重定向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Forwards a request from a servlet to another resource (servlet, JSP file, or HTML file) on the server.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException</span></span><br><span class="line"><span class="function"><span class="comment">//Include： 将当前请求派发到另一个组件，处理完毕后，回到该组件 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">include</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>若需要传送数据到另一个组件，不要在response的输入输出流中进行，可以利用request.setAttribute()方法，在request域中存放数据。</p>
<p>注意：路径中’/‘表示应用的根目录。request的请求转发是应用组件内的转发。而ServeltContext的转发方法可以在用一个tomcat进程中在不同web应用进行转发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Servlet/a&quot;)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="title">throws</span>...</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">         response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">	    <span class="comment">// ！response.getWriter().print(&quot;...1&quot;);</span></span><br><span class="line">        <span class="comment">// text/html  MIME类型</span></span><br><span class="line">    	</span><br><span class="line">        request.setAttribute(<span class="string">&quot;obj&quot;</span>,obj);</span><br><span class="line">  		request.getRequestDispathcer(<span class="string">&quot;/Servlet/b&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="comment">// ！response.getWriter().print(&quot;88&quot;);</span></span><br><span class="line">        <span class="comment">// 若是forward方法，则不能在response的输出流中输出（该组件不能处理response流），应该将要输出的对象先存在reqeust域中，再传给另一个组件。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(必考) response的sendRedirect与request的转发的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request的是由服务端进行转发的，浏览器地址栏不变，只发出一次请求</span><br><span class="line">response的是由客户端进行重定向，浏览器地址栏会改变，相当于发多次请求，效率较低</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>(必考) Filter，其服务函数doFilter()，在Servlet运行之前执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest r1, ServletResponse r2, FilterChain chain)</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest)r1;</span><br><span class="line">    HttpServletResponse response = (HttpServletResponse)r2;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 过滤后，交给Servlet,最后进行后处理。若没有chain.doFilter()，那么该Filter就会产生拦截，不会访问到后面的Servlet</span></span><br><span class="line">    chain.doFilter(requeset,response);   <span class="comment">// 往后传</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后处理</span></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>FilterChain: 用来唤醒下一个filter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filter use the FilterChain to invoke the next filter in the chain, or if the calling filter is the last filter in the chain, to invoke the resource at the end of the chain.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按提供的服务分类有：</p>
<ol>
<li>Authentication Filters</li>
<li>Logging and Auditing Filters</li>
<li>Image conversion Filters</li>
<li>Data compression Filters</li>
<li>Encryption Filters…</li>
</ol>
<p>Filter的拦截配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>f4<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>a.MyFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>f4<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>   <span class="comment">&lt;!--拦截某个servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/sss/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>   <span class="comment">&lt;!--url模式拦截--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个过滤器，EncodingFilter负责设置编码，SecurityFilter负责控制权限，服务器会按照web.xml中过滤器定义的先后循序组装成一条链，然后一次执行其中的doFilter()方法。执行第一个过滤器的chain.doFilter()之前的代码，第二个过滤器的chain.doFilter()之前的代码，请求的资源，第二个过滤器的chain.doFilter()之后的代码，第一个过滤器的chain.doFilter()之后的代码，最后返回响应。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个路径仍然是绝对路径</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/WEB-INF/contact/a.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 这个是可以将web应用的根路径转换成操作系统的路径</span></span><br><span class="line">String s = getServletContext().getRealPath(<span class="string">&quot;/WEB-INF/contact/a.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 若打包到war，这样的路径仍是不对的，可以下面或ClassLoader</span></span><br><span class="line">InputStream in = getServletContext().getResourceAsStream(<span class="string">&quot;/WEB-INF/contact/a.txt&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分页功能，List的subList方法，取出子集合</p>
<h2 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h2><p><img src="/images/1577624122812.png" alt="1577624122812"></p>
<p>构造listener，要么适用WebListener进行注解声明，要么使用ServletContext的addListener()方法进行添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationIntializer</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;</span><br><span class="line">    <span class="comment">//在filter以及servlet之前，ServletContextListener会收到servlet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span></span>&#123;</span><br><span class="line">        ServletContext context = (ServletContext)sce.getServletContext();</span><br><span class="line">        </span><br><span class="line">        DataSource ds = ...;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ServletContextEvent仅有一个方法——getServletContext()，返回<strong>改变了的</strong>ServletContext（发送event的那个ServletContext）</p>
<p>它的父类EventObject还有一个getSource()的方法。</p>
<p>HttpSessionBindingEvent的getValue()返回<strong>旧的值</strong></p>
<h2 id="Jsp"><a href="#Jsp" class="headerlink" title="Jsp"></a>Jsp</h2><p>Jsp本质上是Servlet，是服务器中的组件。tomcat运行jsp时将其转化为.java再编译为.class文件。</p>
<p>JspPage类的生命周期：jspInit(), jspDestroy()</p>
<p>HttpJspPage的服务函数，_jspService(HttpServletRequest request, HttpSerletResponse response){}</p>
<p>二加一方法：</p>
<p>_jspService()方法依赖于特定的协议，因此在java中并不是通用的方法</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time.jsp</span></span><br><span class="line">&lt;%= <span class="keyword">new</span> java.util.Date()%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jsp文件内嵌java代码，语法包括，jsp指令，jsp声明，jsp表达式，jsp注释，jsp脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@     %&gt;				jsp指令的语法（三大指令：page,include,taglib）</span><br><span class="line">&lt;%&#x3D;     %&gt;				jsp表达式的语法</span><br><span class="line">&lt;%!     %&gt;				jsp声明的语法</span><br><span class="line">&lt;%--    --%&gt;			jsp注释</span><br><span class="line">&lt;%      %&gt;				jsp中内嵌java代码 ()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（必考）jsp的九个隐式对象：</p>
<p><img src="/images/1569217469521.png" alt="1569217469521"></p>
<p>exception用在错误处理页面，在声明了isErrorPage=”true”时，才能使用</p>
<p>（重点1）JspWriter</p>
<p>jsp中的数据和模板都是用JspWriter来输出的，由隐式对象out来引用。</p>
<ol>
<li>与System.out.println以及response.getWriter().print()的区别：JspWriter会抛出异常，IOException。记得一定要try-catch。而PrintWriter并不会抛出异常。</li>
<li>out对象存在一个新的缓冲区</li>
</ol>
<p>（重点2）PageContext</p>
<p>fascade pattern 门面模式，将复杂的系统功能抽象为一个“门面”——更加友好的接口。PageContext封装了jsp在运行过程中使用的所有对象。将jsp的对象传给java只需要一个pageContext，由此可以获得其他八个隐式对象。</p>
<p>（注意）下面的程序可能会有NullPointerException</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	String parameter = request.getParameter(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> page = Integer.paraseInt(parameter);</span><br><span class="line">%&gt;</span><br><span class="line"><span class="comment">// http://localhost:8080/SearchPage?page=&amp;id=22</span></span><br><span class="line"><span class="comment">// 若url中有page=但没有参数，那么返回空串；若没有page=则返回null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（注意）jsp声明一般不声明变量，因为在并发情况下这些变量是不安全的，除非加上syncronized修饰</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面转发</span></span><br><span class="line">&lt;jsp:forward page=<span class="string">&quot;/servlet/a&quot;</span> /&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	request.getRequestDispatcher(<span class="string">&quot;/servlet/a&quot;</span>).forward(request,response);</span><br><span class="line">	pageContext.forward(<span class="string">&quot;/servlet/a&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（考）&lt;jsp:include page=”/serlvet/a” /&gt; 与 &lt;%@ include file=”/serlvet/a”%&gt;的区别，第二个是在编译时包含——静态包含，只能包含静态文件，在jsp转换到serlvet过程中进行包含；而第一个是动态包含。</p>
<p>*useBean转换到java代码</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">&quot;a&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.abc.bean.Student&quot;</span> scope=<span class="string">&quot;page|request|session|application&quot;</span> /&gt;</span><br><span class="line"><span class="comment">// 猜数游戏的javaBean应该在session域中</span></span><br><span class="line"><span class="comment">// jsp中取对象属性</span></span><br><span class="line">&lt;jsp:getProperty name=<span class="string">&quot;a&quot;</span> property=<span class="string">&quot;age&quot;</span> /&gt;</span><br><span class="line">&lt;%= a.getAge() %&gt;</span><br><span class="line">$&#123;a.age&#125;</span><br><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;a&quot;</span> property=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;26&quot;</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;a&quot;</span> property=<span class="string">&quot;*&quot;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：javaBean的属性都是小写开头！</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (考试坑)</span></span><br><span class="line">&lt;input name=&quot;Age&quot;&gt;&lt;/intput&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">&quot;a&quot;</span> property=<span class="string">&quot;age&quot;</span> param=<span class="string">&quot;Age&quot;</span>/&gt;</span><br><span class="line"><span class="comment">// 注意param与html中name的大小写！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，jsp也支持简化的表达式语言（EL)，使输出数据更方便${expression}</p>
<p>脚本变量从pageContext, request, session, application这四个作用域中自动依次寻找，如果没有定义，就什么也不输出，不报错。</p>
<p>pageContext：属性作用范围仅限于当前JSP页面<br>request：属性作用范围仅限于同一个请求<br>session：属性作用范围限于一次会话，浏览器打开直到关闭称之为一次会话（在此期间会话不失效）<br>application：属性作用范围限于当前web应用，是范围最大的属性作用范围</p>
<p>EL表达式预定于了11个对象，除了pageContext对象是PageContext类型（考试重点），其余都是Map类型（考试必考）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pageContext</span><br><span class="line">param</span><br><span class="line">paramValues</span><br><span class="line">header</span><br><span class="line">headerValues</span><br><span class="line">cookie</span><br><span class="line">initParam</span><br><span class="line">pageScope</span><br><span class="line">requestScope</span><br><span class="line">sessionScope</span><br><span class="line">applicationScope</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>*MVC(模型-视图-控制器)</p>
<p>分页逻辑：定义一个PageBean，对分页所需要的数据进行管理</p>
<h2 id="自定义标记"><a href="#自定义标记" class="headerlink" title="自定义标记"></a>自定义标记</h2><p>（javax.servlet.jsp.tagext)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记处理器类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.tagext.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*public class TimeTag extends TagSupport&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public int doStartTag() throws JspException&#123;</span></span><br><span class="line"><span class="comment">        // pageContext是TagSupport中的保护成员</span></span><br><span class="line"><span class="comment">        JspWriter out = pageContext.getOut();</span></span><br><span class="line"><span class="comment">        out.println(new Date());</span></span><br><span class="line"><span class="comment">        // 但是此时需要对JspWriter做异常处理</span></span><br><span class="line"><span class="comment">        // 不过这里只能通过try-catch来解决</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SimpleTag不提供doStartTag()和doEndTag()方法，而是提供了更简单的doTag()方法，有更简单的生命周期和接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATag</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span></span>&#123;</span><br><span class="line">    pubilc String color = <span class="string">&quot;black&quot;</span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(string data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException</span>&#123;</span><br><span class="line">        JspWriter out = getJspContext.getOut();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Tag-handler"><a href="#Tag-handler" class="headerlink" title="Tag handler"></a>Tag handler</h2><p>…</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tag的配置  ---创建标签库</span></span><br><span class="line"><span class="comment">// WEB_INF/a.tld</span></span><br><span class="line">&lt;tag-lib&gt;</span><br><span class="line">    <span class="comment">// 给整个标记库定义一个名字</span></span><br><span class="line">    &lt;uri&gt;Http:<span class="comment">//www.abc.com/javaee&lt;/uri&gt;</span></span><br><span class="line">	&lt;tag&gt;</span><br><span class="line">		&lt;name&gt;reset&lt;/name&gt;</span><br><span class="line">        &lt;tag-<span class="class"><span class="keyword">class</span>&gt;<span class="title">ResetTag</span>&lt;/<span class="title">tag</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">body</span>-<span class="title">content</span>&gt;<span class="title">JSP</span>&lt;/<span class="title">body</span>-<span class="title">content</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">tag</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">tag</span>-<span class="title">lib</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 引入到<span class="title">jsp</span>中的方法（必考）</span></span><br><span class="line"><span class="class">&lt;%@ <span class="title">taglib</span> <span class="title">uri</span></span>=<span class="string">&quot;\WEB-INF\a.tld&quot;</span> prefix=<span class="string">&quot;t&quot;</span>%&gt;</span><br><span class="line"><span class="comment">// 若用网上下载的，只有jar包，那么使用整体定义的名字,支持打包</span></span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;Http://www.abc.com/javaee&quot;</span> prefix=<span class="string">&quot;t&quot;</span>%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>*xml命名空间</p>
<p>（问答题）与数据库建立连接时，两种类加载方式的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1, 这种方式需要在编译前就把类放到classpath中</span></span><br><span class="line">Driver driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"><span class="comment">// 2, 通过反射机制</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><p>（必考）Java命名和目录接口（Java Naming and Directory Interface ，JNDI）。主要功能：注册，查找.</p>
<p>JNDI的功能简单说就是可以用简单的方式去查找某种资源。JNDI提供一套标准，服务商去实现SPI，去实现技术细节；程序员去调用API中的方法，不用关心怎么实现的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用命名服务来获得DataSource</span></span><br><span class="line">Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">DataSource ds = (DataSource)ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/ExamDB&quot;</span>);</span><br><span class="line"><span class="comment">// lookup中填写的是 java计算机环境变量  其中“java:comp/env/”为命名前缀</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Structs-1"><a href="#Structs-1" class="headerlink" title="Structs  1"></a>Structs  1</h2><p>a rapid framework for web development based on JavaEE，基于MVC设计模式。降低软件的粒度，提高了Controller的复用性。分为前端控制器和后端控制器。</p>
<p>（曾经考题）structs 框架的配置文件名 不一定要叫 structs-config.xml</p>
<p>前端控制器（ActionServlet），后端控制器（Action）。控制器功能写在execute()函数中。控制器的另一个功能：选择视图输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前端控制器名称：org.apache.structs.action.ActionServlet</span><br><span class="line">后端控制器名称：org.apache.structs.action.Action</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Structs1开发步骤：</p>
<ol>
<li>创建ActionForm的实现，ActionForm是数据表单的对象实现</li>
<li>创建Action的实现，完成其execute()方法</li>
<li>创建数据表单Jsp和结果Jsp</li>
<li>配置structs-config.xml</li>
</ol>
<p>创建后端控制器Action，实现execute方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActionForward <span class="title">execute</span><span class="params">(ActionMapping actionMapping, ActionForm actionForm, HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Action负责页面流程控制、前后台交互。将编写的Action类配置在页面流程控制struts-config.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span>　<span class="attr">name</span>=<span class="string">“xxxForm”</span> <span class="attr">path</span>=<span class="string">“/xxxAction”</span> <span class="attr">scope</span>=<span class="string">“request“</span> <span class="attr">type</span>=<span class="string">&quot;com.jdon.XxxViewAction&quot;</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">forward</span> <span class="attr">name</span>=<span class="string">&quot;forward&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/xxx.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>*（考）DispatchAction (由汇聚到支流)，降低Action数量</p>
<p>Struts1的工作流程:</p>
<ul>
<li>客户端发送请求（Http Request），被struts1的核心控件器ActionServlet接收，ActionServlet根据 struts-config.xml里的映射关系找到对应的Action，若找不到就返回500错误到JSP页面。若有就在 Action里的 excute()方法里执行相应的逻辑操作，比如调用Model层的方法，然后通过ActionForward，跳转到对应的JSP页面。</li>
</ul>
<h2 id="Structs-2"><a href="#Structs-2" class="headerlink" title="Structs 2"></a>Structs 2</h2><p>使用structs 2 的步骤：</p>
<ol>
<li>创建文件夹目录结构：<img src="/images/1570858700925.png" alt="1570858700925"></li>
<li>导入structs2，import struct 2</li>
<li>config, deployment</li>
</ol>
<p>structs2的简单处理流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）浏览器发送请求</span><br><span class="line">2）中心处理器（FilterDispatcher）根据struts.xml文件查找对应的处理请求的Action类</span><br><span class="line">3）WebWork的拦截器链自动对请求应用通用功能，例如：WorkFlow、Validation等功能</span><br><span class="line">4）如果Struts.xml文件中配置Method参数，则调用Method参数对应的Action类中的Method方法，否则调用通用的Execute方法来处理用户请求</span><br><span class="line">5）将Action类中的对应方法返回的结果响应给浏览器</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>structs 1 与 structs 2的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）Action类的实现方式：Struts1的Action在实现的时候必须扩展Action类或者Action的子类（DispatchAction），Struts2的Action类实现的时候可以不用实现任何类和接口</span><br><span class="line">2)Struts1的Action类是单例模式，必须设计成线程安全的，Struts2则为每一个请求产生一个实例</span><br><span class="line">3)Struts1的Action类依赖与Servlet API，execute方法有HttpServletRequest和HttpServletResponse，Struts2则不依赖于Servlet API；</span><br><span class="line">4）Struts1的Action与View通过ActionForm或者其子类进行数据传递 而struts2去掉了formbean</span><br><span class="line">5)Struts1绑定了JSTL，为页面的编写带来方便，Struts2整合了ONGL，也可以使用JSTL</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ResourceBundle 支持国际化，</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>是一个轻量级控制反转（IoC）和面向切面编程（AOP）的容器。</p>
<p>（考试）什么是IoC，DI?</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IoC(Inversion of Control)控制反转：将对象的生命周期控制，交给第三方容器</span><br><span class="line">DI(Dependency injection)依赖注入：组件之间的依赖关系由容器在运行期决定，即	由容器动态地将某种依赖关系注入到组件之中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>*工厂模式， 工厂方法模式， 抽象工厂模式</p>
<p>（考）ClassPathXmlApplicationContext ,FileSystemXmlApplicationContext   前者的xml文件在classpath中（支持打包），后者通过绝对路径指定xml文件。</p>
<p>web应用中创建spring容器，使用XmlWebApplicationContext。听众接口：ServletContextListener，其中两个事件处理函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 必考要记</span><br><span class="line">public void contextInitialized(ServletContextEvent sce)&#123;</span><br><span class="line">	Context ctx &#x3D; new InitialContext();</span><br><span class="line">	DataSource ds &#x3D; (DataSource)ctx.lookup(&quot;java:comp&#x2F;env&#x2F;jdbc&#x2F;ExamDB&quot;);</span><br><span class="line">	sce.getServletContext().setAttribute(&quot;ds&quot;,ds);</span><br><span class="line">&#125;</span><br><span class="line">public void contextDestroyed(ServletContextEvent sce)&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>*（必考）web.xml中声明一个组件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span><span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>                     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AOP编程</p>
<p>（任务）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">理解BeanFactory</span><br><span class="line">理解ApplicationContext</span><br><span class="line">理解FileSystemXmlApplicationContext</span><br><span class="line">理解ClassPathXmlApplicationContext</span><br><span class="line">理解XmlWebApplicationContext</span><br><span class="line">重点理解JavaEE Web Application如何集成Spring框架</span><br><span class="line">理解Spring framework的配置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>spring mvc 前端控制器的mapping 不要使用/* , 而应该使用/ (优先级最低) ,否则会拦截.jsp</p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>基本处理流程：</p>
<p><img src="/images/1577616911675.png" alt="1577616911675"></p>
<ol>
<li>用户请求首先发送到前端控制器DispatcherServlet，DispatcherServlet根据请求的信息来决定使用哪个页面控制器Controller来处理该请求。找到控制器之后，DispatcherServlet将请求委托给控制器去处理。</li>
<li>接下来页面控制器开始处理用户请求，页面控制器会根据请求信息进行处理，调用业务层等等，处理完成之后，会把结果封装成一个ModelAndView返回给DispatcherServlet。</li>
<li>前端控制器DispatcherServlet接到页面控制器的返回结果后，根据返回的视图名选择相应的视图模板，并根据返回的数据进行渲染。</li>
<li>最后前端控制器DispatcherServlet将结果返回给用户。</li>
</ol>
<p>备注：</p>
<ol>
<li>DispatcherServlet相当于前端控制器: org.springframework.web.servlet.DispatcherServlet</li>
<li>Handler（需要自己开发）是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。</li>
<li>前端控制器的url-pattern应该是/，而不是/*</li>
</ol>
<p>Spring的后端控制器可以用xml配置，也可以用注解来声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.abc.project.controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span></span>&#123;</span><br><span class="line">    <span class="comment">// 路径到处理函数的映射</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/calc/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(<span class="meta">@RequestParam(value=&quot;v1&quot;)</span> String v1,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="meta">@RequestParam(value=&quot;v2&quot;)</span> String v2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在配置文件中开启mvc</span><br><span class="line">&lt;mvc:annotation-driven/&gt;</span><br><span class="line">在配置文件中启动扫描组件，注意是包的名字</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.abc.project.controller&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>MVC 各自的作用以及关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">View 访问模型，显示模型层的内容</span><br><span class="line">Controller 前端控制器：访问View(可复用) 后端控制器: 访问模型(不可复用)</span><br><span class="line">Model 模型层主要负责保存和访问业务逻辑，执行业务逻辑和操作。（不可复用）</span><br><span class="line">特点：</span><br><span class="line">1）多个视图可以对应一个模型，增强了了代码的重用性，减少代码量，易于维护</span><br><span class="line">2）分离视图层和业务逻辑层，可维护性高</span><br><span class="line">3）降低了各层之间的耦合性，提供了应用的可扩展性</span><br><span class="line">4）MVC更符合软件工程化管理的精神，各层各司其职</span><br><span class="line">5）使用MVC模式使开发时间得到相当大的缩减，部署加快</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>是一个对象关系映射框架，对JDBC进行了轻量级的对象封装。可以自动生成SQL语句，自动执行。</p>
<p>Hibernate使用<strong>反射机制</strong>实现持久化对象的操作。</p>

      
    </div>
    
    
    

    

    

    
	

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/02/%E3%80%90%E5%8D%9A%E5%AE%A2%E3%80%91Github-Page-Hexo%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/" rel="next" title="【博客】Github Page + Hexo实现静态博客">
                <i class="fa fa-chevron-left"></i> 【博客】Github Page + Hexo实现静态博客
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/" rel="prev" title="微信小程序学习">
                微信小程序学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/person.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ChocoFairy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wanlizhao@mail.dlut.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%B0%8F%E5%AD%A6%E6%9C%9F%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">Java小学期笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-vs-C"><span class="nav-number">1.1.</span> <span class="nav-text">Java vs C++</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.0.0.1.</span> <span class="nav-text">1, 数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">1.1.0.0.2.</span> <span class="nav-text">2, 参数传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="nav-number">1.1.0.0.3.</span> <span class="nav-text">3, 对象存储与访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6"><span class="nav-number">1.1.0.0.4.</span> <span class="nav-text">4, 对象回收</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.</span> <span class="nav-text">Java中的运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.0.0.1.</span> <span class="nav-text">1,  算术运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.0.0.2.</span> <span class="nav-text">2,  关系运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.0.0.3.</span> <span class="nav-text">3,  逻辑运算</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.3.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">1.4.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81%EF%BC%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.</span> <span class="nav-text">继承，多态，接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.6.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.7.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.9.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">1.10.</span> <span class="nav-text">多线程编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.11.</span> <span class="nav-text">网络编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">1.12.</span> <span class="nav-text">事件处理机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.13.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDBC"><span class="nav-number">1.14.</span> <span class="nav-text">JDBC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#J2EE%E7%AC%94%E8%AE%B0"><span class="nav-number">2.</span> <span class="nav-text">J2EE笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet"><span class="nav-number">2.2.</span> <span class="nav-text">Servlet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session"><span class="nav-number">2.3.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RequestDispatcher"><span class="nav-number">2.4.</span> <span class="nav-text">RequestDispatcher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filter"><span class="nav-number">2.5.</span> <span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#listener"><span class="nav-number">2.6.</span> <span class="nav-text">listener</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jsp"><span class="nav-number">2.7.</span> <span class="nav-text">Jsp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AE%B0"><span class="nav-number">2.8.</span> <span class="nav-text">自定义标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tag-handler"><span class="nav-number">2.9.</span> <span class="nav-text">Tag handler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JNDI"><span class="nav-number">2.10.</span> <span class="nav-text">JNDI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Structs-1"><span class="nav-number">2.11.</span> <span class="nav-text">Structs  1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Structs-2"><span class="nav-number">2.12.</span> <span class="nav-text">Structs 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">2.13.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC"><span class="nav-number">2.14.</span> <span class="nav-text">SpringMVC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate"><span class="nav-number">2.15.</span> <span class="nav-text">Hibernate</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wlz</span>

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>






        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


   <!--<script type="text/javascript" src="//libs.baidu.com/jquery/2.1.3/jquery.min.js"></script>
   雪花特效2
  <script type="text/javascript" src="/js/snow2.js"></script>--> 
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>

